variables:
  GIT_SUBMODULE_STRATEGY: recursive
  GIT_STRATEGY: clone
  # Note: keep "rpm-installer-centos8" and "debian-installer-ubuntu20" job names below
  # consistent with OS versions.
  UBUNTU20_BASE_IMAGE: ubuntu:20.04
  UBUNTU18_BASE_IMAGE: ubuntu:18.04
  CENTOS_BASE_IMAGE: centos:8
  # Projects may want to use images in their own namespace
  UBUNTU20_CPP_IMAGE: $DOCKER_REGISTRY/${CI_API_V4_URL}/rewriting/gtirb-functions/ubuntu20
  UBUNTU18_CPP_IMAGE: $DOCKER_REGISTRY/${CI_API_V4_URL}/rewriting/gtirb-functions/ubuntu18
  # CENTOS_CPP_IMAGE: $DOCKER_REGISTRY/$CI_PROJECT_NAMESPACE/hello/centos8



stages:
  - check-format
  - test
  - build
  - cpack-make-installers
  - cpack-test
  - cpack-test-shared-lib
  - cpack-deploy
  - test_package
  - deploy

default:
  image: $DOCKER_REGISTRY/rewriting/gtirb-functions
  tags: ['kubernetes']
  before_script:
    - pip install --pre --extra-index-url=$EXTRA_INDEX_URL .

check-format:
  stage: check-format
  before_script: []
  script:
    - pre-commit install-hooks
    - pre-commit run --all-files --show-diff-on-failure
    # helper message for new committers
    - |+
      cat <<EOF
      ================================================================================
      If this stage fails, the formatting of your changes may be incorrect.
      To automatically format your files, install pre-commit:
          pip3 install pre-commit
          pre-commit install
      pre-commit will now automatically format any files before commit.
      To fix any misformatted files, run:
          pre-commit run --all-files
      And then commit any changes.
      More information regarding pre-commit can be found at https://pre-commit.com.

      NOTE FOR PROJECTS WITH C/C++ CODE:
      pre-commit will by default use the correct version of every formatting tool
      EXCEPT FOR clang-format. You need to ensure the version of clang-format you
      use is EXACTLY version 6.0.0. This is available in Ubuntu 18 by default.
      ================================================================================
      EOF

test:
  stage: test
  script:
    - pip install -r requirements-dev.txt
    - mypy gtirb_functions
    - python3 setup.py test

build:
  stage: build
  artifacts:
    paths:
      - dist/gtirb-functions-*-py3-none-any.whl
    expire_in: 1 weeks
  script:
    - python3 setup.py sdist bdist_wheel

test_package:
  variables:
    GIT_STRATEGY: none
  stage: test_package
  before_script: []
  script:
    - for f in dist/*.whl; do python3 -m pip install $f; done

export_external:
  stage: deploy
  script:
    - pip install -r requirements-dev.txt
    - python3 setup.py bdist_wheel --dist-dir=$CI_PROJECT_DIR/dist
    - VERSION=$(python3 -c "from imp import load_source; pkginfo = load_source('pkginfo.version', 'gtirb_functions/version.py'); print(pkginfo.__version__)")
    # Do not publish .dev versions on the public pypi
    - if [[ "$VERSION" =~ \.dev[[:digit:]]*.*$ ]]; then exit 1; fi
    - python3 -m twine upload --verbose $CI_PROJECT_DIR/dist/*.whl -u __token__ -p $PYPI_API_KEY
  rules:
    - if: '$CI_COMMIT_REF_NAME =~ /^release-.*/'

export_internal:
  stage: deploy
  script:
    - pip install -r requirements-dev.txt
    - python3 setup.py bdist_wheel --dist-dir=$CI_PROJECT_DIR/dist
    - VERSION=$(python3 -c "from imp import load_source; pkginfo = load_source('pkginfo.version', 'gtirb-functions/version.py'); print(pkginfo.__version__)")
    - if [[ "$VERSION" =~ \.dev[[:digit:]]*.*$ && "$CI_COMMIT_REF_NAME" =~ ^release-.* ]]; then exit 1; fi
    # this job is not using $CI_JOB_TOKEN because it only has read access
    # https://gitlab.com/gitlab-org/gitlab/-/issues/35067
    # this job is also not using $CI_DEPLOY_USER and $CI_DEPLOY_PASSWORD because it only has write access
    - if [[ "$CI_COMMIT_BRANCH" == "master" ]]; then
        if [[ ! "$VERSION" =~ \.dev[[:digit:]]*$ ]]; then
          echo "[ERROR] On the master branch, we must be exporting a -dev version.";
          exit 1;
        fi;
        if pip3 install --extra-index-url=$EXTRA_INDEX_URL "gtirb-functions>$VERSION" 2>/dev/null; then
          echo "[ERROR] The package version being published on master should always be >= the version in the repository.";
          exit 1;
        fi;
        wget ${CI_SERVER_HOST}/research/templates/python-module/raw/master/delete_remote_packages.py;
        python3 $CI_PROJECT_DIR/delete_remote_packages.py $GL_PKG_API_TOKEN dist/*.whl;
      fi
    - wget ${CI_SERVER_HOST}/research/templates/python-module/raw/master/.pypirc
    - sed "s/password = <access token>/password = $GL_PKG_API_TOKEN/" $CI_PROJECT_DIR/.pypirc > ~/.pypirc
    - python3 -m twine upload --verbose --repository repypi $CI_PROJECT_DIR/dist/*.whl
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
    - if: '$CI_COMMIT_REF_NAME =~ /^release-.*/'
    # If you need to publish a package for a specific branch, change the
    # package version to something like, '0.0.0.dev0+mybranchname', uncomment
    # the rule below and replace 'mybranchname' with your branch name.
    #- if: '$CI_COMMIT_BRANCH == "mybranchname"'
    #  changes:
    #    - src/version.py


.conan-template: &conan-template
  - conan profile new default --detect
  - conan profile update settings.compiler.libcxx=libstdc++11 default
  - conan remote add gitlab ${CI_API_V4_URL}/packages/conan
  - export CONAN_PASSWORD="$CI_JOB_TOKEN"
  - conan user ci_user -r gitlab -p

.ubuntu-build-template: &ubuntu-build
  stage: build
  needs: [check-format]
  script:
    - *conan-template
    - python3 create-conan-package.py --build=missing

build-ubuntu20:
  image: ${UBUNTU20_CPP_IMAGE}
  <<: *ubuntu-build

build-ubuntu18:
  image: ${UBUNTU18_CPP_IMAGE}
  <<: *ubuntu-build

coverage:
  stage: build
  needs: [check-format]
  image: ${UBUNTU20_CPP_IMAGE}
  script:
    - *conan-template
    - mkdir build
    - cd build
    - conan install ..
    - cmake -DENABLE_CODE_COVERAGE=ON -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON ..
    - make
    - ctest
    - gcovr -e googletest-src -r ..

# CPack jobs:

.build-cpack-template: &build-cpack
  stage: build
  needs: [check-format]
  artifacts:
    paths:
      - build/
  script:
    - *conan-template
    - mkdir build
    - cd build
    - conan install ..
    - cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DGTIRB_FUNCTION_STRIP_DEBUG_SYMBOLS=ON ..
    - make
    - ctest
    - cpack -G DEB -D CPACK_GTIRB_FUNCTION_PACKAGE=lib
    - cpack -G DEB -D CPACK_GTIRB_FUNCTION_PACKAGE=lib-dbg
    - cpack -G DEB -D CPACK_GTIRB_FUNCTION_PACKAGE=dev


.setup-repo: &setup-repo
  stage: cpack-make-installers
  artifacts:
    paths:
      - installers/
  script:
    - mkdir installers/
    - cp build/*.deb installers/
    - cd installers/ && dpkg-scanpackages . /dev/null > Packages

.cpack-update-apt-sources-template: &cpack-update-apt-sources-template |
    echo -e "\ndeb [trusted=yes] file:$(pwd)/installers/ ./\n" >> /etc/apt/sources.list
    apt-get update -y

.cpack-check-lib-build-id: &cpack-check-lib-build-id |
    [ -f /usr/lib/debug/.build-id/$(readelf -n /usr/lib/libgtirb-functions.so | grep "Build ID: " | cut -d":" -f2 | sed -E "s/ ([a-f0-9]{2})([a-f0-9]{30,})/\1\/\2/g").debug ]

.test-dev: &test-dev
  stage: cpack-test
  artifacts:
    paths:
      - test-install
  script:
    - *cpack-update-apt-sources-template
    - apt-get install -y libgtirb-functions-dev
    - cp src/main.cpp ./ && g++ main.cpp -o test-install -lgtirb-functions -lstdc++
    - ./test-install GrammaTech

.test-lib: &test-lib
  stage: cpack-test-shared-lib
  script:
    - *cpack-update-apt-sources-template
    - apt-get install -y libgtirb-functions-dev
    - ./test-install GrammaTech



.test-lib-dbg: &test-lib-dbg
  stage: cpack-test
  script:
    - 'echo -e "\ndeb [trusted=yes] file:$(pwd)/installers/ ./\n" >> /etc/apt/sources.list'
    - apt-get update -y
    - apt-get install -y libgtirb-functions libgtirb-functions-dbg
    - '[ -f /usr/lib/debug/.build-id/$(readelf -n /usr/lib/libgtirb-functions.so | grep "Build ID: " | cut -d":" -f2 | sed -E "s/ ([a-f0-9]{2,})([a-f0-9]{30,})/\1\/\2/g").debug ]'

.debian-deploy: &debian-deploy
  stage: cpack-deploy
  artifacts:
    paths:
      - '*gtirb-functions*.deb'
  script:
    - cp installers/*.deb ./

build-cpack-ubuntu18:
  image: ${UBUNTU18_CPP_IMAGE}
  <<: *build-cpack

setup-repo-ubuntu18:
  needs: [build-cpack-ubuntu18]
  image: ${UBUNTU18_CPP_IMAGE}
  <<: *setup-repo

test-dev-ubuntu18:
  needs: [setup-repo-ubuntu18]
  image: ${UBUNTU18_CPP_IMAGE}
  <<: *test-dev

test-lib-ubuntu18:
  needs: [setup-repo-ubuntu18, test-dev-ubuntu18]
  image: ${UBUNTU18_BASE_IMAGE}
  <<: *test-lib

test-lib-dbg-ubuntu18:
  needs: [setup-repo-ubuntu18]
  image: ${UBUNTU18_CPP_IMAGE}
  <<: *test-lib-dbg

deploy-ubuntu18:
  needs: [setup-repo-ubuntu18, test-dev-ubuntu18, test-lib-ubuntu18]
  image: ${UBUNTU18_BASE_IMAGE}
  <<: *debian-deploy

build-cpack-ubuntu20:
  image: ${UBUNTU20_CPP_IMAGE}
  <<: *build-cpack

setup-repo-ubuntu20:
  image: ${UBUNTU20_CPP_IMAGE}
  needs: [build-cpack-ubuntu20]
  <<: *setup-repo

test-dev-ubuntu20:
  image: ${UBUNTU20_CPP_IMAGE}
  needs: [setup-repo-ubuntu20]
  <<: *test-dev

test-lib-ubuntu20:
  image: ${UBUNTU20_BASE_IMAGE}
  needs: [setup-repo-ubuntu20, test-dev-ubuntu20]
  <<: *test-lib

test-lib-dbg-ubuntu20:
  image: ${UBUNTU20_CPP_IMAGE}
  needs: [setup-repo-ubuntu20]
  <<: *test-lib-dbg

deploy-ubuntu20:
  image: ${UBUNTU20_BASE_IMAGE}
  needs: [setup-repo-ubuntu20, test-dev-ubuntu20, test-lib-ubuntu20]
  <<: *debian-deploy
